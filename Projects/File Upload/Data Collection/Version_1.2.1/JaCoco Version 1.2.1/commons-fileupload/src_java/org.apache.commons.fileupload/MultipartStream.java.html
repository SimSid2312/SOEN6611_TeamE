<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>MultipartStream.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-fileupload (Apr 4, 2019 4:29:55 AM)</a> &gt; <a href="../../index.html" class="el_group">commons-fileupload</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.fileupload</a> &gt; <span class="el_source">MultipartStream.java</span></div><h1>MultipartStream.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.fileupload;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

import org.apache.commons.fileupload.util.Closeable;
import org.apache.commons.fileupload.util.Streams;

/**
 * &lt;p&gt; Low level API for processing file uploads.
 *
 * &lt;p&gt; This class can be used to process data streams conforming to MIME
 * 'multipart' format as defined in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc1867.txt&quot;&gt;RFC 1867&lt;/a&gt;. Arbitrarily
 * large amounts of data in the stream can be processed under constant
 * memory usage.
 *
 * &lt;p&gt; The format of the stream is defined in the following way:&lt;br&gt;
 *
 * &lt;code&gt;
 *   multipart-body := preamble 1*encapsulation close-delimiter epilogue&lt;br&gt;
 *   encapsulation := delimiter body CRLF&lt;br&gt;
 *   delimiter := &quot;--&quot; boundary CRLF&lt;br&gt;
 *   close-delimiter := &quot;--&quot; boudary &quot;--&quot;&lt;br&gt;
 *   preamble := &amp;lt;ignore&amp;gt;&lt;br&gt;
 *   epilogue := &amp;lt;ignore&amp;gt;&lt;br&gt;
 *   body := header-part CRLF body-part&lt;br&gt;
 *   header-part := 1*header CRLF&lt;br&gt;
 *   header := header-name &quot;:&quot; header-value&lt;br&gt;
 *   header-name := &amp;lt;printable ascii characters except &quot;:&quot;&amp;gt;&lt;br&gt;
 *   header-value := &amp;lt;any ascii characters except CR &amp; LF&amp;gt;&lt;br&gt;
 *   body-data := &amp;lt;arbitrary data&amp;gt;&lt;br&gt;
 * &lt;/code&gt;
 *
 * &lt;p&gt;Note that body-data can contain another mulipart entity.  There
 * is limited support for single pass processing of such nested
 * streams.  The nested stream is &lt;strong&gt;required&lt;/strong&gt; to have a
 * boundary token of the same length as the parent stream (see {@link
 * #setBoundary(byte[])}).
 *
 * &lt;p&gt;Here is an example of usage of this class.&lt;br&gt;
 *
 * &lt;pre&gt;
 *    try {
 *        MultipartStream multipartStream = new MultipartStream(input,
 *                                                              boundary);
 *        boolean nextPart = multipartStream.skipPreamble();
 *        OutputStream output;
 *        while(nextPart) {
 *            header = chunks.readHeader();
 *            // process headers
 *            // create some output stream
 *            multipartStream.readBodyPart(output);
 *            nextPart = multipartStream.readBoundary();
 *        }
 *    } catch(MultipartStream.MalformedStreamException e) {
 *          // the stream failed to follow required syntax
 *    } catch(IOException) {
 *          // a read or write error occurred
 *    }
 *
 * &lt;/pre&gt;
 *
 * @author &lt;a href=&quot;mailto:Rafal.Krzewski@e-point.pl&quot;&gt;Rafal Krzewski&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:martinc@apache.org&quot;&gt;Martin Cooper&lt;/a&gt;
 * @author Sean C. Sullivan
 *
 * @version $Id$
 */
public class MultipartStream {
    /**
     * Internal class, which is used to invoke the
     * {@link ProgressListener}.
     */
    static class ProgressNotifier {
        /** The listener to invoke.
         */
        private final ProgressListener listener;
        /** Number of expected bytes, if known, or -1.
         */
        private final long contentLength;
        /** Number of bytes, which have been read so far.
         */
        private long bytesRead;
        /** Number of items, which have been read so far.
         */
        private int items;
        /** Creates a new instance with the given listener
         * and content length.
         * @param pListener The listener to invoke.
         * @param pContentLength The expected content length.
         */
<span class="fc" id="L112">        ProgressNotifier(ProgressListener pListener, long pContentLength) {</span>
<span class="fc" id="L113">            listener = pListener;</span>
<span class="fc" id="L114">            contentLength = pContentLength;</span>
<span class="fc" id="L115">        }</span>
        /** Called to indicate that bytes have been read.
         * @param pBytes Number of bytes, which have been read.
         */
        void noteBytesRead(int pBytes) {
            /* Indicates, that the given number of bytes have been read from
             * the input stream.
             */
<span class="fc" id="L123">            bytesRead += pBytes;</span>
<span class="fc" id="L124">            notifyListener();</span>
<span class="fc" id="L125">        }</span>
        /** Called to indicate, that a new file item has been detected.
         */
        void noteItem() {
<span class="fc" id="L129">            ++items;</span>
<span class="fc" id="L130">        }</span>
        /** Called for notifying the listener.
         */
        private void notifyListener() {
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L135">                listener.update(bytesRead, contentLength, items);</span>
            }
<span class="fc" id="L137">        }</span>
    }

    // ----------------------------------------------------- Manifest constants


    /**
     * The Carriage Return ASCII character value.
     */
    public static final byte CR = 0x0D;


    /**
     * The Line Feed ASCII character value.
     */
    public static final byte LF = 0x0A;


    /**
     * The dash (-) ASCII character value.
     */
    public static final byte DASH = 0x2D;


    /**
     * The maximum length of &lt;code&gt;header-part&lt;/code&gt; that will be
     * processed (10 kilobytes = 10240 bytes.).
     */
    public static final int HEADER_PART_SIZE_MAX = 10240;


    /**
     * The default length of the buffer used for processing a request.
     */
    protected static final int DEFAULT_BUFSIZE = 4096;


    /**
     * A byte sequence that marks the end of &lt;code&gt;header-part&lt;/code&gt;
     * (&lt;code&gt;CRLFCRLF&lt;/code&gt;).
     */
<span class="fc" id="L178">    protected static final byte[] HEADER_SEPARATOR = {</span>
<span class="fc" id="L179">        CR, LF, CR, LF };</span>


    /**
     * A byte sequence that that follows a delimiter that will be
     * followed by an encapsulation (&lt;code&gt;CRLF&lt;/code&gt;).
     */
<span class="fc" id="L186">    protected static final byte[] FIELD_SEPARATOR = {</span>
<span class="fc" id="L187">        CR, LF};</span>


    /**
     * A byte sequence that that follows a delimiter of the last
     * encapsulation in the stream (&lt;code&gt;--&lt;/code&gt;).
     */
<span class="fc" id="L194">    protected static final byte[] STREAM_TERMINATOR = {</span>
<span class="fc" id="L195">        DASH, DASH};</span>


    /**
     * A byte sequence that precedes a boundary (&lt;code&gt;CRLF--&lt;/code&gt;).
     */
<span class="fc" id="L201">    protected static final byte[] BOUNDARY_PREFIX = {</span>
<span class="fc" id="L202">        CR, LF, DASH, DASH};</span>


    // ----------------------------------------------------------- Data members


    /**
     * The input stream from which data is read.
     */
    private final InputStream input;


    /**
     * The length of the boundary token plus the leading &lt;code&gt;CRLF--&lt;/code&gt;.
     */
    private int boundaryLength;


    /**
     * The amount of data, in bytes, that must be kept in the buffer in order
     * to detect delimiters reliably.
     */
    private int keepRegion;


    /**
     * The byte sequence that partitions the stream.
     */
    private byte[] boundary;


    /**
     * The length of the buffer used for processing the request.
     */
    private final int bufSize;


    /**
     * The buffer used for processing the request.
     */
    private final byte[] buffer;


    /**
     * The index of first valid character in the buffer.
     * &lt;br&gt;
     * 0 &lt;= head &lt; bufSize
     */
    private int head;


    /**
     * The index of last valid characer in the buffer + 1.
     * &lt;br&gt;
     * 0 &lt;= tail &lt;= bufSize
     */
    private int tail;


    /**
     * The content encoding to use when reading headers.
     */
    private String headerEncoding;


    /**
     * The progress notifier, if any, or null.
     */
    private final ProgressNotifier notifier;

    // ----------------------------------------------------------- Constructors

    /**
     * Creates a new instance.
     * @deprecated Use {@link #MultipartStream(InputStream, byte[],
     * org.apache.commons.fileupload.MultipartStream.ProgressNotifier)},
     * or {@link #MultipartStream(InputStream, byte[], int,
     * org.apache.commons.fileupload.MultipartStream.ProgressNotifier)}
     */
    public MultipartStream() {
<span class="nc" id="L282">        this(null, null, null);</span>
<span class="nc" id="L283">    }</span>

    /**
     * &lt;p&gt; Constructs a &lt;code&gt;MultipartStream&lt;/code&gt; with a custom size buffer
     * and no progress notifier.
     *
     * &lt;p&gt; Note that the buffer must be at least big enough to contain the
     * boundary string, plus 4 characters for CR/LF and double dash, plus at
     * least one byte of data.  Too small a buffer size setting will degrade
     * performance.
     *
     * @param input    The &lt;code&gt;InputStream&lt;/code&gt; to serve as a data source.
     * @param boundary The token used for dividing the stream into
     *                 &lt;code&gt;encapsulations&lt;/code&gt;.
     * @param bufSize  The size of the buffer to be used, in bytes.
     *
     * @see #MultipartStream(InputStream, byte[],
     *   MultipartStream.ProgressNotifier)
     * @deprecated Use {@link #MultipartStream(InputStream, byte[], int,
     *  org.apache.commons.fileupload.MultipartStream.ProgressNotifier)}.
     */
    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {
<span class="nc" id="L305">        this(input, boundary, bufSize, null);</span>
<span class="nc" id="L306">    }</span>

    /**
     * &lt;p&gt; Constructs a &lt;code&gt;MultipartStream&lt;/code&gt; with a custom size buffer.
     *
     * &lt;p&gt; Note that the buffer must be at least big enough to contain the
     * boundary string, plus 4 characters for CR/LF and double dash, plus at
     * least one byte of data.  Too small a buffer size setting will degrade
     * performance.
     *
     * @param input    The &lt;code&gt;InputStream&lt;/code&gt; to serve as a data source.
     * @param boundary The token used for dividing the stream into
     *                 &lt;code&gt;encapsulations&lt;/code&gt;.
     * @param bufSize  The size of the buffer to be used, in bytes.
     * @param pNotifier The notifier, which is used for calling the
     *                  progress listener, if any.
     *
     * @see #MultipartStream(InputStream, byte[],
     *     MultipartStream.ProgressNotifier)
     */
<span class="fc" id="L326">    MultipartStream(InputStream input,</span>
            byte[] boundary,
            int bufSize,
            ProgressNotifier pNotifier) {
<span class="fc" id="L330">        this.input = input;</span>
<span class="fc" id="L331">        this.bufSize = bufSize;</span>
<span class="fc" id="L332">        this.buffer = new byte[bufSize];</span>
<span class="fc" id="L333">        this.notifier = pNotifier;</span>

        // We prepend CR/LF to the boundary to chop trailng CR/LF from
        // body-data tokens.
<span class="fc" id="L337">        this.boundary = new byte[boundary.length + BOUNDARY_PREFIX.length];</span>
<span class="fc" id="L338">        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;</span>
<span class="fc" id="L339">        this.keepRegion = this.boundary.length;</span>
<span class="fc" id="L340">        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,</span>
<span class="fc" id="L341">                BOUNDARY_PREFIX.length);</span>
<span class="fc" id="L342">        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,</span>
<span class="fc" id="L343">                boundary.length);</span>

<span class="fc" id="L345">        head = 0;</span>
<span class="fc" id="L346">        tail = 0;</span>
<span class="fc" id="L347">    }</span>


    /**
     * &lt;p&gt; Constructs a &lt;code&gt;MultipartStream&lt;/code&gt; with a default size buffer.
     *
     * @param input    The &lt;code&gt;InputStream&lt;/code&gt; to serve as a data source.
     * @param boundary The token used for dividing the stream into
     *                 &lt;code&gt;encapsulations&lt;/code&gt;.
     * @param pNotifier An object for calling the progress listener, if any.
     *
     *
     * @see #MultipartStream(InputStream, byte[], int,
     *     MultipartStream.ProgressNotifier)
     */
    MultipartStream(InputStream input,
            byte[] boundary,
            ProgressNotifier pNotifier) {
<span class="fc" id="L365">        this(input, boundary, DEFAULT_BUFSIZE, pNotifier);</span>
<span class="fc" id="L366">    }</span>

    /**
     * &lt;p&gt; Constructs a &lt;code&gt;MultipartStream&lt;/code&gt; with a default size buffer.
     *
     * @param input    The &lt;code&gt;InputStream&lt;/code&gt; to serve as a data source.
     * @param boundary The token used for dividing the stream into
     *                 &lt;code&gt;encapsulations&lt;/code&gt;.
     *
     * @deprecated Use {@link #MultipartStream(InputStream, byte[],
     *  MultipartStream.ProgressNotifier)}.
     * @see #MultipartStream(InputStream, byte[], int,
     *  MultipartStream.ProgressNotifier)
     */
    public MultipartStream(InputStream input,
            byte[] boundary) {
<span class="nc" id="L382">        this(input, boundary, DEFAULT_BUFSIZE, null);</span>
<span class="nc" id="L383">    }</span>

    // --------------------------------------------------------- Public methods


    /**
     * Retrieves the character encoding used when reading the headers of an
     * individual part. When not specified, or &lt;code&gt;null&lt;/code&gt;, the platform
     * default encoding is used.

     *
     * @return The encoding used to read part headers.
     */
    public String getHeaderEncoding() {
<span class="nc" id="L397">        return headerEncoding;</span>
    }


    /**
     * Specifies the character encoding to be used when reading the headers of
     * individual parts. When not specified, or &lt;code&gt;null&lt;/code&gt;, the platform
     * default encoding is used.
     *
     * @param encoding The encoding used to read part headers.
     */
    public void setHeaderEncoding(String encoding) {
<span class="fc" id="L409">        headerEncoding = encoding;</span>
<span class="fc" id="L410">    }</span>


    /**
     * Reads a byte from the &lt;code&gt;buffer&lt;/code&gt;, and refills it as
     * necessary.
     *
     * @return The next byte from the input stream.
     *
     * @throws IOException if there is no more data available.
     */
    public byte readByte() throws IOException {
        // Buffer depleted ?
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (head == tail) {</span>
<span class="fc" id="L424">            head = 0;</span>
            // Refill.
<span class="fc" id="L426">            tail = input.read(buffer, head, bufSize);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            if (tail == -1) {</span>
                // No more data available.
<span class="nc" id="L429">                throw new IOException(&quot;No more data is available&quot;);</span>
            }
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">            if (notifier != null) {</span>
<span class="fc" id="L432">                notifier.noteBytesRead(tail);</span>
            }
        }
<span class="fc" id="L435">        return buffer[head++];</span>
    }


    /**
     * Skips a &lt;code&gt;boundary&lt;/code&gt; token, and checks whether more
     * &lt;code&gt;encapsulations&lt;/code&gt; are contained in the stream.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if there are more encapsulations in
     *         this stream; &lt;code&gt;false&lt;/code&gt; otherwise.
     *
     * @throws MalformedStreamException if the stream ends unexpecetedly or
     *                                  fails to follow required syntax.
     */
    public boolean readBoundary()
            throws MalformedStreamException {
<span class="fc" id="L451">        byte[] marker = new byte[2];</span>
<span class="fc" id="L452">        boolean nextChunk = false;</span>

<span class="fc" id="L454">        head += boundaryLength;</span>
        try {
<span class="fc" id="L456">            marker[0] = readByte();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">            if (marker[0] == LF) {</span>
                // Work around IE5 Mac bug with input type=image.
                // Because the boundary delimiter, not including the trailing
                // CRLF, must not appear within any file (RFC 2046, section
                // 5.1.1), we know the missing CR is due to a buggy browser
                // rather than a file containing something similar to a
                // boundary.
<span class="fc" id="L464">                return true;</span>
            }

<span class="fc" id="L467">            marker[1] = readByte();</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (arrayequals(marker, STREAM_TERMINATOR, 2)) {</span>
<span class="fc" id="L469">                nextChunk = false;</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {</span>
<span class="fc" id="L471">                nextChunk = true;</span>
<span class="fc" id="L472">            } else {</span>
<span class="nc" id="L473">                throw new MalformedStreamException(</span>
<span class="nc" id="L474">                &quot;Unexpected characters follow a boundary&quot;);</span>
            }
<span class="nc" id="L476">        } catch (IOException e) {</span>
<span class="nc" id="L477">            throw new MalformedStreamException(&quot;Stream ended unexpectedly&quot;);</span>
        }
<span class="fc" id="L479">        return nextChunk;</span>
    }


    /**
     * &lt;p&gt;Changes the boundary token used for partitioning the stream.
     *
     * &lt;p&gt;This method allows single pass processing of nested multipart
     * streams.
     *
     * &lt;p&gt;The boundary token of the nested stream is &lt;code&gt;required&lt;/code&gt;
     * to be of the same length as the boundary token in parent stream.
     *
     * &lt;p&gt;Restoring the parent stream boundary token after processing of a
     * nested stream is left to the application.
     *
     * @param boundary The boundary to be used for parsing of the nested
     *                 stream.
     *
     * @throws IllegalBoundaryException if the &lt;code&gt;boundary&lt;/code&gt;
     *                                  has a different length than the one
     *                                  being currently parsed.
     */
    public void setBoundary(byte[] boundary)
            throws IllegalBoundaryException {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {</span>
<span class="nc" id="L505">            throw new IllegalBoundaryException(</span>
<span class="nc" id="L506">            &quot;The length of a boundary token can not be changed&quot;);</span>
        }
<span class="fc" id="L508">        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,</span>
<span class="fc" id="L509">                boundary.length);</span>
<span class="fc" id="L510">    }</span>


    /**
     * &lt;p&gt;Reads the &lt;code&gt;header-part&lt;/code&gt; of the current
     * &lt;code&gt;encapsulation&lt;/code&gt;.
     *
     * &lt;p&gt;Headers are returned verbatim to the input stream, including the
     * trailing &lt;code&gt;CRLF&lt;/code&gt; marker. Parsing is left to the
     * application.
     *
     * &lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt; allow limiting maximum header size to
     * protect against abuse.
     *
     * @return The &lt;code&gt;header-part&lt;/code&gt; of the current encapsulation.
     *
     * @throws MalformedStreamException if the stream ends unexpecetedly.
     */
    public String readHeaders()
    throws MalformedStreamException {
<span class="fc" id="L530">        int i = 0;</span>
        byte b;
        // to support multi-byte characters
<span class="fc" id="L533">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L534">        int size = 0;</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        while (i &lt; HEADER_SEPARATOR.length) {</span>
            try {
<span class="fc" id="L537">                b = readByte();</span>
<span class="pc" id="L538">            } catch (IOException e) {</span>
<span class="nc" id="L539">                throw new MalformedStreamException(&quot;Stream ended unexpectedly&quot;);</span>
            }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (++size &gt; HEADER_PART_SIZE_MAX) {</span>
<span class="nc" id="L542">                throw new MalformedStreamException(</span>
<span class="nc" id="L543">                        &quot;Header section has more than &quot; + HEADER_PART_SIZE_MAX</span>
                        + &quot; bytes (maybe it is not properly terminated)&quot;);
            }
<span class="fc bfc" id="L546" title="All 2 branches covered.">            if (b == HEADER_SEPARATOR[i]) {</span>
<span class="fc" id="L547">                i++;</span>
<span class="fc" id="L548">            } else {</span>
<span class="fc" id="L549">                i = 0;</span>
            }
<span class="fc" id="L551">            baos.write(b);</span>
        }

<span class="fc" id="L554">        String headers = null;</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        if (headerEncoding != null) {</span>
            try {
<span class="nc" id="L557">                headers = baos.toString(headerEncoding);</span>
<span class="nc" id="L558">            } catch (UnsupportedEncodingException e) {</span>
                // Fall back to platform default if specified encoding is not
                // supported.
<span class="nc" id="L561">                headers = baos.toString();</span>
            }
<span class="nc" id="L563">        } else {</span>
<span class="fc" id="L564">            headers = baos.toString();</span>
        }

<span class="fc" id="L567">        return headers;</span>
    }


    /**
     * &lt;p&gt;Reads &lt;code&gt;body-data&lt;/code&gt; from the current
     * &lt;code&gt;encapsulation&lt;/code&gt; and writes its contents into the
     * output &lt;code&gt;Stream&lt;/code&gt;.
     *
     * &lt;p&gt;Arbitrary large amounts of data can be processed by this
     * method using a constant size buffer. (see {@link
     * #MultipartStream(InputStream,byte[],int,
     *   MultipartStream.ProgressNotifier) constructor}).
     *
     * @param output The &lt;code&gt;Stream&lt;/code&gt; to write data into. May
     *               be null, in which case this method is equivalent
     *               to {@link #discardBodyData()}.
     *
     * @return the amount of data written.
     *
     * @throws MalformedStreamException if the stream ends unexpectedly.
     * @throws IOException              if an i/o error occurs.
     */
    public int readBodyData(OutputStream output)
            throws MalformedStreamException, IOException {
<span class="fc" id="L592">        final InputStream istream = newInputStream();</span>
<span class="fc" id="L593">        return (int) Streams.copy(istream, output, false);</span>
    }

    /**
     * Creates a new {@link ItemInputStream}.
     * @return A new instance of {@link ItemInputStream}.
     */
    ItemInputStream newInputStream() {
<span class="fc" id="L601">        return new ItemInputStream();</span>
    }

    /**
     * &lt;p&gt; Reads &lt;code&gt;body-data&lt;/code&gt; from the current
     * &lt;code&gt;encapsulation&lt;/code&gt; and discards it.
     *
     * &lt;p&gt;Use this method to skip encapsulations you don't need or don't
     * understand.
     *
     * @return The amount of data discarded.
     *
     * @throws MalformedStreamException if the stream ends unexpectedly.
     * @throws IOException              if an i/o error occurs.
     */
    public int discardBodyData()
    throws MalformedStreamException,
    IOException {
<span class="fc" id="L619">        return readBodyData(null);</span>
    }


    /**
     * Finds the beginning of the first &lt;code&gt;encapsulation&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if an &lt;code&gt;encapsulation&lt;/code&gt; was found in
     *         the stream.
     *
     * @throws IOException if an i/o error occurs.
     */
    public boolean skipPreamble()
    throws IOException {
        // First delimiter may be not preceeded with a CRLF.
<span class="fc" id="L634">        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);</span>
<span class="fc" id="L635">        boundaryLength = boundary.length - 2;</span>
        try {
            // Discard all data up to the delimiter.
<span class="fc" id="L638">            discardBodyData();</span>

            // Read boundary - if succeded, the stream contains an
            // encapsulation.
<span class="fc" id="L642">            return readBoundary();</span>
<span class="nc" id="L643">        } catch (MalformedStreamException e) {</span>
<span class="nc" id="L644">            return false;</span>
<span class="pc" id="L645">        } finally {</span>
            // Restore delimiter.
<span class="pc" id="L647">            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);</span>
<span class="pc" id="L648">            boundaryLength = boundary.length;</span>
<span class="pc" id="L649">            boundary[0] = CR;</span>
<span class="pc" id="L650">            boundary[1] = LF;</span>
<span class="pc" id="L651">        }</span>
    }


    /**
     * Compares &lt;code&gt;count&lt;/code&gt; first bytes in the arrays
     * &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
     *
     * @param a     The first array to compare.
     * @param b     The second array to compare.
     * @param count How many bytes should be compared.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;count&lt;/code&gt; first bytes in arrays
     *         &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal.
     */
    public static boolean arrayequals(byte[] a,
            byte[] b,
            int count) {
<span class="fc bfc" id="L669" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (a[i] != b[i]) {</span>
<span class="fc" id="L671">                return false;</span>
            }
        }
<span class="fc" id="L674">        return true;</span>
    }


    /**
     * Searches for a byte of specified value in the &lt;code&gt;buffer&lt;/code&gt;,
     * starting at the specified &lt;code&gt;position&lt;/code&gt;.
     *
     * @param value The value to find.
     * @param pos   The starting position for searching.
     *
     * @return The position of byte found, counting from beginning of the
     *         &lt;code&gt;buffer&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; if not found.
     */
    protected int findByte(byte value,
            int pos) {
<span class="fc bfc" id="L690" title="All 2 branches covered.">        for (int i = pos; i &lt; tail; i++) {</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">            if (buffer[i] == value) {</span>
<span class="fc" id="L692">                return i;</span>
            }
        }

<span class="fc" id="L696">        return -1;</span>
    }


    /**
     * Searches for the &lt;code&gt;boundary&lt;/code&gt; in the &lt;code&gt;buffer&lt;/code&gt;
     * region delimited by &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;.
     *
     * @return The position of the boundary found, counting from the
     *         beginning of the &lt;code&gt;buffer&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; if
     *         not found.
     */
    protected int findSeparator() {
        int first;
<span class="fc" id="L710">        int match = 0;</span>
<span class="fc" id="L711">        int maxpos = tail - boundaryLength;</span>
<span class="fc" id="L712">        for (first = head;</span>
<span class="fc bfc" id="L713" title="All 4 branches covered.">        (first &lt;= maxpos) &amp;&amp; (match != boundaryLength);</span>
<span class="fc" id="L714">        first++) {</span>
<span class="fc" id="L715">            first = findByte(boundary[0], first);</span>
<span class="fc bfc" id="L716" title="All 4 branches covered.">            if (first == -1 || (first &gt; maxpos)) {</span>
<span class="fc" id="L717">                return -1;</span>
            }
<span class="fc bfc" id="L719" title="All 2 branches covered.">            for (match = 1; match &lt; boundaryLength; match++) {</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">                if (buffer[first + match] != boundary[match]) {</span>
<span class="fc" id="L721">                    break;</span>
                }
            }
        }
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (match == boundaryLength) {</span>
<span class="fc" id="L726">            return first - 1;</span>
        }
<span class="fc" id="L728">        return -1;</span>
    }

    /**
     * Thrown to indicate that the input stream fails to follow the
     * required syntax.
     */
    public static class MalformedStreamException
    extends IOException {
        /**
         * Constructs a &lt;code&gt;MalformedStreamException&lt;/code&gt; with no
         * detail message.
         */
        public MalformedStreamException() {
<span class="nc" id="L742">            super();</span>
<span class="nc" id="L743">        }</span>

        /**
         * Constructs an &lt;code&gt;MalformedStreamException&lt;/code&gt; with
         * the specified detail message.
         *
         * @param message The detail message.
         */
        public MalformedStreamException(String message) {
<span class="fc" id="L752">            super(message);</span>
<span class="fc" id="L753">        }</span>
    }


    /**
     * Thrown upon attempt of setting an invalid boundary token.
     */
    public static class IllegalBoundaryException
            extends IOException {
        /**
         * Constructs an &lt;code&gt;IllegalBoundaryException&lt;/code&gt; with no
         * detail message.
         */
        public IllegalBoundaryException() {
<span class="nc" id="L767">            super();</span>
<span class="nc" id="L768">        }</span>

        /**
         * Constructs an &lt;code&gt;IllegalBoundaryException&lt;/code&gt; with
         * the specified detail message.
         *
         * @param message The detail message.
         */
        public IllegalBoundaryException(String message) {
<span class="nc" id="L777">            super(message);</span>
<span class="nc" id="L778">        }</span>
    }

    /**
     * An {@link InputStream} for reading an items contents.
     */
    public class ItemInputStream extends InputStream implements Closeable {
        /** The number of bytes, which have been read so far.
         */
        private long total;
        /** The number of bytes, which must be hold, because
         * they might be a part of the boundary.
         */
        private int pad;
        /** The current offset in the buffer.
         */
        private int pos;
        /** Whether the stream is already closed.
         */
        private boolean closed;

        /**
         * Creates a new instance.
         */
<span class="fc" id="L802">        ItemInputStream() {</span>
<span class="fc" id="L803">            findSeparator();</span>
<span class="fc" id="L804">        }</span>

        /**
         * Called for finding the separator.
         */
        private void findSeparator() {
<span class="fc" id="L810">            pos = MultipartStream.this.findSeparator();</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            if (pos == -1) {</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">                if (tail - head &gt; keepRegion) {</span>
<span class="fc" id="L813">                    pad = keepRegion;</span>
<span class="fc" id="L814">                } else {</span>
<span class="fc" id="L815">                    pad = tail - head;</span>
                }
            }
<span class="fc" id="L818">        }</span>

        /**
         * Returns the number of bytes, which have been read
         * by the stream.
         * @return Number of bytes, which have been read so far.
         */
        public long getBytesRead() {
<span class="nc" id="L826">            return total;</span>
        }

        /**
         * Returns the number of bytes, which are currently
         * available, without blocking.
         * @throws IOException An I/O error occurs.
         * @return Number of bytes in the buffer.
         */
        public int available() throws IOException {
<span class="fc bfc" id="L836" title="All 2 branches covered.">            if (pos == -1) {</span>
<span class="fc" id="L837">                return tail - head - pad;</span>
            }
<span class="fc" id="L839">            return pos - head;</span>
        }

        /** Offset when converting negative bytes to integers.
         */
        private static final int BYTE_POSITIVE_OFFSET = 256;

        /**
         * Returns the next byte in the stream.
         * @return The next byte in the stream, as a non-negative
         *   integer, or -1 for EOF.
         * @throws IOException An I/O error occurred.
         */
        public int read() throws IOException {
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">            if (closed) {</span>
<span class="nc" id="L854">                throw new FileItemStream.ItemSkippedException();</span>
            }
<span class="fc bfc" id="L856" title="All 2 branches covered.">            if (available() == 0) {</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">                if (makeAvailable() == 0) {</span>
<span class="fc" id="L858">                    return -1;</span>
                }
            }
<span class="fc" id="L861">            ++total;</span>
<span class="fc" id="L862">            int b = buffer[head++];</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">            if (b &gt;= 0) {</span>
<span class="fc" id="L864">                return b;</span>
            }
<span class="fc" id="L866">            return b + BYTE_POSITIVE_OFFSET;</span>
        }

        /**
         * Reads bytes into the given buffer.
         * @param b The destination buffer, where to write to.
         * @param off Offset of the first byte in the buffer.
         * @param len Maximum number of bytes to read.
         * @return Number of bytes, which have been actually read,
         *   or -1 for EOF.
         * @throws IOException An I/O error occurred.
         */
        public int read(byte[] b, int off, int len) throws IOException {
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">            if (closed) {</span>
<span class="nc" id="L880">                throw new FileItemStream.ItemSkippedException();</span>
            }
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L883">                return 0;</span>
            }
<span class="fc" id="L885">            int res = available();</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">            if (res == 0) {</span>
<span class="fc" id="L887">                res = makeAvailable();</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (res == 0) {</span>
<span class="fc" id="L889">                    return -1;</span>
                }
            }
<span class="fc" id="L892">            res = Math.min(res, len);</span>
<span class="fc" id="L893">            System.arraycopy(buffer, head, b, off, res);</span>
<span class="fc" id="L894">            head += res;</span>
<span class="fc" id="L895">            total += res;</span>
<span class="fc" id="L896">            return res;</span>
        }

        /**
         * Closes the input stream.
         * @throws IOException An I/O error occurred.
         */
        public void close() throws IOException {
<span class="fc" id="L904">            close(false);</span>
<span class="fc" id="L905">        }</span>

        /**
         * Closes the input stream.
         * @param pCloseUnderlying Whether to close the underlying stream
         *   (hard close)
         * @throws IOException An I/O error occurred.
         */
        public void close(boolean pCloseUnderlying) throws IOException {
<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc" id="L915">                return;</span>
            }
<span class="fc bfc" id="L917" title="All 2 branches covered.">            if (pCloseUnderlying) {</span>
<span class="fc" id="L918">                closed = true;</span>
<span class="fc" id="L919">                input.close();</span>
<span class="fc" id="L920">            } else {</span>
<span class="nc" id="L921">                for (;;) {</span>
<span class="fc" id="L922">                    int av = available();</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">                    if (av == 0) {</span>
<span class="fc" id="L924">                        av = makeAvailable();</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">                        if (av == 0) {</span>
<span class="fc" id="L926">                            break;</span>
                        }
                    }
<span class="nc" id="L929">                    skip(av);</span>
                }
            }
<span class="fc" id="L932">            closed = true;</span>
<span class="fc" id="L933">        }</span>

        /**
         * Skips the given number of bytes.
         * @param bytes Number of bytes to skip.
         * @return The number of bytes, which have actually been
         *   skipped.
         * @throws IOException An I/O error occurred.
         */
        public long skip(long bytes) throws IOException {
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (closed) {</span>
<span class="nc" id="L944">                throw new FileItemStream.ItemSkippedException();</span>
            }
<span class="nc" id="L946">            int av = available();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (av == 0) {</span>
<span class="nc" id="L948">                av = makeAvailable();</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                if (av == 0) {</span>
<span class="nc" id="L950">                    return 0;</span>
                }
            }
<span class="nc" id="L953">            long res = Math.min(av, bytes);</span>
<span class="nc" id="L954">            head += res;</span>
<span class="nc" id="L955">            return res;</span>
        }

        /**
         * Attempts to read more data.
         * @return Number of available bytes
         * @throws IOException An I/O error occurred.
         */
        private int makeAvailable() throws IOException {
<span class="fc bfc" id="L964" title="All 2 branches covered.">            if (pos != -1) {</span>
<span class="fc" id="L965">                return 0;</span>
            }

            // Move the data to the beginning of the buffer.
<span class="fc" id="L969">            total += tail - head - pad;</span>
<span class="fc" id="L970">            System.arraycopy(buffer, tail - pad, buffer, 0, pad);</span>

            // Refill buffer with new data.
<span class="fc" id="L973">            head = 0;</span>
<span class="fc" id="L974">            tail = pad;</span>

            for (;;) {
<span class="fc" id="L977">                int bytesRead = input.read(buffer, tail, bufSize - tail);</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                if (bytesRead == -1) {</span>
                    // The last pad amount is left in the buffer.
                    // Boundary can't be in there so signal an error
                    // condition.
<span class="fc" id="L982">                    final String msg = &quot;Stream ended unexpectedly&quot;;</span>
<span class="fc" id="L983">                    throw new MalformedStreamException(msg);</span>
                }
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">                if (notifier != null) {</span>
<span class="fc" id="L986">                    notifier.noteBytesRead(bytesRead);</span>
                }
<span class="fc" id="L988">                tail += bytesRead;</span>

<span class="fc" id="L990">                findSeparator();</span>
<span class="fc" id="L991">                int av = available();</span>

<span class="fc bfc" id="L993" title="All 4 branches covered.">                if (av &gt; 0 || pos != -1) {</span>
<span class="fc" id="L994">                    return av;</span>
                }
            }
        }

        /**
         * Returns, whether the stream is closed.
         * @return True, if the stream is closed, otherwise false.
         */
        public boolean isClosed() {
<span class="fc" id="L1004">            return closed;</span>
        }
    }

    // ------------------------------------------------------ Debugging methods


    // These are the methods that were used to debug this stuff.
    /*

    // Dump data.
    protected void dump()
    {
        System.out.println(&quot;01234567890&quot;);
        byte[] temp = new byte[buffer.length];
        for(int i=0; i&lt;buffer.length; i++)
        {
            if (buffer[i] == 0x0D || buffer[i] == 0x0A)
            {
                temp[i] = 0x21;
            }
            else
            {
                temp[i] = buffer[i];
            }
        }
        System.out.println(new String(temp));
        int i;
        for (i=0; i&lt;head; i++)
            System.out.print(&quot; &quot;);
        System.out.println(&quot;h&quot;);
        for (i=0; i&lt;tail; i++)
            System.out.print(&quot; &quot;);
        System.out.println(&quot;t&quot;);
        System.out.flush();
    }

    // Main routine, for testing purposes only.
    //
    // @param args A String[] with the command line arguments.
    // @throws Exception, a generic exception.
    public static void main( String[] args )
        throws Exception
    {
        File boundaryFile = new File(&quot;boundary.dat&quot;);
        int boundarySize = (int)boundaryFile.length();
        byte[] boundary = new byte[boundarySize];
        FileInputStream input = new FileInputStream(boundaryFile);
        input.read(boundary,0,boundarySize);

        input = new FileInputStream(&quot;multipart.dat&quot;);
        MultipartStream chunks = new MultipartStream(input, boundary);

        int i = 0;
        String header;
        OutputStream output;
        boolean nextChunk = chunks.skipPreamble();
        while (nextChunk)
        {
            header = chunks.readHeaders();
            System.out.println(&quot;!&quot;+header+&quot;!&quot;);
            System.out.println(&quot;wrote part&quot;+i+&quot;.dat&quot;);
            output = new FileOutputStream(&quot;part&quot;+(i++)+&quot;.dat&quot;);
            chunks.readBodyData(output);
            nextChunk = chunks.readBoundary();
        }
    }

     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span>commons-fileupload (Apr 4, 2019 4:29:55 AM)</div></body></html>